# Topic 8 Callbacks and Callback Hell

---
![]()
### **Concept**

**What is a Callback in Node.js?**

* A **callback** is a **function passed as an argument** to another function, which is then **executed after an asynchronous task completes**.
* It allows Node.js to handle tasks like reading files, making API calls, etc., **without blocking** other operations.

---

### **Why Callbacks?**

| Need                    | Explanation                                                       |
| ----------------------- | ----------------------------------------------------------------- |
| **Asynchronous Nature** | Node.js performs I/O operations without blocking the main thread. |
| **Event-driven Design** | Callback functions act as “listeners” for completion events.      |
| **Non-blocking Code**   | You can continue executing other code while waiting for results.  |

---

### **How It Works**

* The main thread calls an async function (like reading a file).
* Instead of waiting for the result, Node registers a **callback** to handle it later.
* Once the task completes, the **Event Loop** invokes the callback function with the result or error.

---

### **Folder Setup**

```
callbacks-demo/
│
├── app.js
└── data/
    └── info.txt
```

---

### **Code Example 1: Simple Callback Function**

**File:** `app.js`

```js
// ===========================
// Example: Simple Callback
// ===========================

// A function that accepts another function as callback
function greetUser(name, callback) {
  console.log("Hi " + name);
  callback(); // Execute the callback function
}

// Passing a function as an argument
greetUser("Tanish", () => {
  console.log("Welcome to Node.js!");
});
```

**Output:**

```
Hi Tanish
Welcome to Node.js!
```

---

### **Code Example 2: Using Callbacks with fs Module**

**File:** `app.js` (updated)

```js
// ===========================
// Example: Asynchronous Callback (fs.readFile)
// ===========================

const fs = require('fs');

// Read file asynchronously
fs.readFile('./data/info.txt', 'utf8', (err, data) => {
  if (err) {
    console.log("Error reading file:", err);
  } else {
    console.log("File Content:", data);
  }
});

console.log("Reading file... please wait!");
```

**Output Example:**

```
Reading file... please wait!
File Content: Hello! This text was read using an asynchronous callback.
```

> Note: The “Reading file...” line appears **first**, proving non-blocking async behavior.

---

### **Concept: Callback Hell**

* **Callback Hell** occurs when **multiple async functions** depend on each other, leading to **nested callbacks**.
* The code becomes hard to **read, debug, and maintain** — also known as the **“Pyramid of Doom.”**

---

### **Code Example 3: Callback Hell Example**

**File:** `callback-hell.js`

```js
// ===========================
// Example: Callback Hell
// ===========================

const fs = require('fs');

// Step 1: Create a file
fs.writeFile('./data/task.txt', 'Task started', (err) => {
  if (err) throw err;
  console.log('File created!');

  // Step 2: Append data
  fs.appendFile('./data/task.txt', '\nStep 2 completed.', (err) => {
    if (err) throw err;
    console.log('Data appended!');

    // Step 3: Read file
    fs.readFile('./data/task.txt', 'utf8', (err, data) => {
      if (err) throw err;
      console.log('File content:\n', data);

      // Step 4: Rename file
      fs.rename('./data/task.txt', './data/final-task.txt', (err) => {
        if (err) throw err;
        console.log('File renamed successfully!');
      });
    });
  });
});
```

**Output Example:**

```
File created!
Data appended!
File content:
 Task started
Step 2 completed.
File renamed successfully!
```

> Notice the **deep nesting** of callbacks — this is callback hell.

---

### **Problem with Callback Hell**

* Code becomes **hard to read** and **unmaintainable**.
* Error handling becomes complex.
* Logic dependencies grow exponentially as tasks increase.

---

### **Mini Project: Async File Workflow (Callback-based)**

**Goal:** Create, append, read, and delete a log file using only callbacks.

**Folder:**

```
callback-project/
│
├── app.js
└── logs/
```

**File:** `app.js`

```js
// ===========================
// Mini Project: File Workflow with Callbacks
// ===========================

const fs = require('fs');

// Step 1: Create log file
fs.writeFile('./logs/app.log', 'Server started...\n', (err) => {
  if (err) return console.log("Error creating file:", err);
  console.log("Log file created.");

  // Step 2: Append log
  fs.appendFile('./logs/app.log', 'New request received...\n', (err) => {
    if (err) return console.log("Error appending data:", err);
    console.log("Log updated.");

    // Step 3: Read log file
    fs.readFile('./logs/app.log', 'utf8', (err, data) => {
      if (err) return console.log("Error reading file:", err);
      console.log("\nLog Content:\n", data);

      // Step 4: Delete file
      fs.unlink('./logs/app.log', (err) => {
        if (err) return console.log("Error deleting file:", err);
        console.log("Log file deleted successfully.");
      });
    });
  });
});
```

**Run in terminal:**

```bash
node app.js
```

**Output Example:**

```
Log file created.
Log updated.

Log Content:
 Server started...
New request received...

Log file deleted successfully.
```

---

### **Dependencies**

* No external dependencies — uses **built-in fs module**.

---

### **Notes**

* Callbacks are the **foundation of async programming** in Node.js.
* Always handle errors in callbacks as the **first argument (`err`)**.
* Use callbacks carefully — deep nesting leads to **callback hell**.
* Solutions to callback hell:

  * **Promises**
  * **Async/Await**

---
